#!/usr/bin/env bash
# shellcheck disable=SC2124

set -ueo pipefail

source "$(dirname "${BASH_SOURCE[0]}")/logging"

# Checks if a value exists in an array
#
# Arguments:
#   $1 - NEEDLE
#   $2 - HAYSTACK
#
# Returns:
#   0 if needle is found
#   1 otherwise

common::has_item() {
    local HAYSTACK NEEDLE="$1"
    shift
    for HAYSTACK; do [[ "$HAYSTACK" == "$NEEDLE" ]] && return 0; done
    return 1
}

# Checks the specified variables are set and non-empty
#
# Arguments:
#   VAR1 VAR2 ...
#
# Returns:
#   0 on success
#   1 if any variable is unset or empty

common::require() {
    for REQUIRED_VAR in "$@"; do
        : "${!REQUIRED_VAR:?Error: $REQUIRED_VAR is not set but required}"
    done
}

# Checks if a given package is available to install.
#
# Globals:
#   OS_NAME
#
# Arguments:
#   $1 - PACKAGE
#
# Returns:
#   0 on success
#   non-zero if PACKAGE isn't available.

common::has_pkg() {

    local -r PACKAGE="$1"

    common::require OS_NAME

    case $OS_NAME in
    fedora)
        dnf list --available "$PACKAGE" &>/dev/null
        ;;
    xUbuntu | debian)
        apt-cache show "$PACKAGE" &>/dev/null
        ;;
    *)
        log::not_implemented
        return 1
        ;;
    esac
}

# Queries an inventory YAML file using 'yq' to retrieve dependencies for a
# specific caller or target. It merges cross-distro common packages names with
# those specific to the current $PKG_MANAGER and $OS_NAME.
#
# Globals:
#   OS
#   ARCH
#   OS_NAME
#   XDG_BIN_HOME
#   PKG_MANAGER
#   PKG_INVENTORY
#
# Arguments:
#   $1 - FUNCTION_CALLEE Optional. The key to look up in the YAML.
#        Defaults to the name of the calling function without its namespace.
#
# Outputs:
#   Writes a space-separated string of package names to stdout.
#
# Returns:
#   0 on success
#   non-zero if any global is not set or yq installation fails.

common::dependencies_from() {

    local -r FUNCTION_CALLEE="${1:-FUNCNAME[1]##*::}"

    common::require OS OS_NAME ARCH XDG_BIN_HOME PKG_MANAGER PKG_INVENTORY_FILE

    command -v yq &>/dev/null || {
        #shellcheck disable=SC2015
        common::has_pkg "yq" && $PKG_MANAGER install -y yq >/dev/null || {
            local -r YQ_LATEST_BIN_RELEASE_URL="https://github.com/mikefarah/yq/releases/latest/download/yq_${OS}_${ARCH}"
            curl -sSfLo "$XDG_BIN_HOME/yq" "$YQ_LATEST_BIN_RELEASE_URL" && chmod +x "$XDG_BIN_HOME/yq"
        }
    }

    local COMMON_PKGS PKG_MANAGER_PKGS OS_PKGS

    COMMON_PKGS=$(yq -r ".dependencies.${FUNCTION_CALLEE}.common // [] | join(\" \")" "$PKG_INVENTORY_FILE")
    PKG_MANAGER_PKGS=$(yq -r ".dependencies.${FUNCTION_CALLEE}.${PKG_MANAGER} // [] | join(\" \")" "$PKG_INVENTORY_FILE")
    OS_PKGS=$(yq -r ".dependencies.${FUNCTION_CALLEE}.${OS_NAME} // [] | join(\" \")" "$PKG_INVENTORY_FILE")

    echo "$COMMON_PKGS $PKG_MANAGER_PKGS $OS_PKGS"
}

# Identifies the OS package manager by checking available commands
# and OS release files.
#
# It first attempts to find common package managers in PATH,
# then falls back to /etc/*-release files.
#
# Arguments:
#   None
# Outputs:
#   Writes the package manager to stdout
#   Any error to stderr
# Returns:
#   0 if package manager is detected
#   1 if no package manager could be determined

common::package_manager() {

    local -ra PACKAGE_MANAGERS=(
        "apt-get"
        "dnf"
        "pacman"
        "zypper"
        "apk"
        "emerge"
    )

    for PACKAGE_MANAGER in "${PACKAGE_MANAGERS[@]}"; do
        if [[ $(command -v "$PACKAGE_MANAGER") ]]; then
            echo "$PACKAGE_MANAGER"
            return 0
        fi
    done

    local -rA OS_FILENAMES=(
        ["/etc/debian_version"]=apt-get
        ["/etc/redhat-release"]=dnf
        ["/etc/arch-release"]=pacman
        ["/etc/SUSE-release"]=zypper
        ["/etc/alpine-release"]=apk
        ["/etc/gentoo-release"]=emerge
    )

    for DISTRIBUTION in "${!OS_FILENAMES[@]}"; do
        [[ -f $DISTRIBUTION ]] && {
            echo "${OS_FILENAMES[$DISTRIBUTION]}"
            return 0
        }
    done

    log::error "Couldn't determine the OS package manager."
}

# Displays an interactive menu using bash select and executes
# the given mapped function.
# Globals:
#   PS3
# Arguments:
#   $1 - SETTINGS.        An associative array where each key is an option and the value is the function to execute
#   $2 - PROMPT Optional. Prompt text.
#                         Default: "Select an option"
# Outputs:
#   Options and function output to stdout
#   Any error to stderr
# Returns:
#   0 on success
#   1 if the mapped function doesn't exist
# Example:
#   declare -A options=(
#       ["PackageA"]="install_packageA"
#       ["PackageB"]="install_packageB|arg1|arg2"
#   )
#
#   common::choose options "Choose a package"

common::choose() {

    local -n SETTINGS=$1
    local -r PROMPT=${2:-"Select an option"}
    local -a OPTIONS=()

    for option in "${!SETTINGS[@]}"; do
        OPTIONS+=("$option")
    done

    PS3="${PROMPT}: "

    show_options() {
        for i in "${!OPTIONS[@]}"; do
            printf "%d) %s\n" $((i + 1)) "${OPTIONS[$i]}"
        done
    }

    select CHOICE in "${OPTIONS[@]}"; do
        [[ -z $CHOICE ]] && {
            log::info "Oops! Option unavailable, Please choose a correct one."
            show_options
            continue
        }

        IFS='|' read -r -a FN_SIGNATURE <<<"${SETTINGS[$CHOICE]}"

        if [[ ${#FN_SIGNATURE} -eq 0 ]]; then
            log::error "${CHOICE} requires to be mapped to an action."
        fi

        local -r FN_NAME="${FN_SIGNATURE[0]}"
        local -r FN_ARGS="${FN_SIGNATURE[@]:1}"

        declare -F "$FN_NAME" &>/dev/null || {
            log::error "$FN_NAME isn't a recognized action."
        }

        "$FN_NAME" "$FN_ARGS"
        break
    done
    unset -f show_options
}

# Displays a progress spinner. Requires to properly handle its clean up
# in case of any failure in between of start/stop
# Globals:
#   SPIN_CHARS
#   SPIN_PID
#   ON_SUCCESS_MSG
#   ON_ERROR_MSG
# Arguments:
#   $1 - PROGRESS_MSG   Optional: Message to show while the action is progressing
#                       Default: Installing $FUNCTION_CALLEE_NAME...
#   $2 - ON_SUCCESS_MSG Optional: Message on success
#                       Default: $FUNCTION_CALLE_NAME OK
#   $3 - ON_ERROR_MSG   Optional: Message on error
#                       Default: $FUNCTION_CALLE_NAME KO
# Outputs:
#   PROGRESS_MSG to stdout
#   ON_SUCCESS_MSG to stdout
#   ON_ERROR_MSG to stderr
# Example:
#   common::start_spinner
#   do_something
#   common::stop_spinner

readonly SPIN_CHARS="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"

ON_SUCCESS_MSG=""
ON_ERROR_MSG=""

SPIN_PID=""

common::start_spinner() {

    local -r FUNCTION_CALLEE="${FUNCNAME[1]##*::}"
    local -r PROGRESS_MSG="${1:-"Installing ${FUNCTION_CALLEE}..."}"

    ON_SUCCESS_MSG="${2:-"${BOLD}${FUNCTION_CALLEE} ${GREEN}OK${NC}"}"
    ON_ERROR_MSG="${3:-"${BOLD}${FUNCTION_CALLEE} ${RED}KO${NC}"}"

    common::__start_spinner "$PROGRESS_MSG" &
    SPIN_PID=$!
    disown
}

common::stop_spinner() {

    local -r EXIT_CODE=$?
    ON_SUCCESS_MSG=${1:-$ON_SUCCESS_MSG}
    common::__stop_spinner $EXIT_CODE
}

common::__start_spinner() {

    local i=0
    local -r MESSAGE="$1"
    local -r n=${#SPIN_CHARS}

    tput civis

    while true; do
        printf "\r\033[K\033[36m%s\033[0m %s" "${SPIN_CHARS:i:1}" "$MESSAGE"
        i=$(((i + 1) % n))
        sleep 0.05
    done
}

common::__stop_spinner() {

    local EXIT_CODE=${1:-0}
    local TRIGGERED_BY_SIGNAL=${2:-false}

    if [[ -n "$SPIN_PID" ]] && kill -0 "$SPIN_PID" 2>/dev/null; then
        kill "$SPIN_PID" 2>/dev/null
        wait "$SPIN_PID" 2>/dev/null
    fi

    tput cnorm

    [[ $TRIGGERED_BY_SIGNAL == "true" && $EXIT_CODE -eq 0 ]] && return 0

    [[ $EXIT_CODE -eq 0 ]] &&
        echo -ne "\r\033[K${GREEN}✔${NC} ${ON_SUCCESS_MSG}\n" ||
        echo -ne "\r\033[K${RED}✖${NC} ${ON_ERROR_MSG}\n" >&2

    SPIN_PID=""
}

# Initiates a persistent sudo session and spawns a background job to
# refresh sudo's session expiration timestamp every 90s.
# To prevent orphaned processes, use a trap calling
# common::__stop_sudo_keepalive for cleanup.
# Globals:
#   SUDO_KEEPALIVE_PID

SUDO_KEEPALIVE_PID=""

common::start_sudo_keepalive() {

    command -v sudo >/dev/null 2>&1 || return 0

    if [[ -n "$SUDO_KEEPALIVE_PID" ]] && kill -0 "$SUDO_KEEPALIVE_PID" 2>/dev/null; then
        return 0
    fi

    log::info "Requesting sudo privileges:"
    sudo -v || log::error "Failed to obtain sudo privileges"

    (
        while true; do
            sleep 90
            sudo -v 2>/dev/null || exit 0
        done
    ) &>/dev/null &

    SUDO_KEEPALIVE_PID=$!
    disown
}

common::__stop_sudo_keepalive() {

    if [[ -n "$SUDO_KEEPALIVE_PID" ]] && kill -0 "$SUDO_KEEPALIVE_PID" 2>/dev/null; then
        kill "$SUDO_KEEPALIVE_PID" 2>/dev/null
        wait "$SUDO_KEEPALIVE_PID" 2>/dev/null
        SUDO_KEEPALIVE_PID=""
    fi
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    log::error "Execution denied: This script is a library and must be sourced."
fi
