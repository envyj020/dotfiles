# vim: set ft=sh:
# shellcheck disable=SC2015

alias ls='ls -F -h --color=always --time-style=long-iso'
alias ll='ls -la'
alias lt='ls -s -1 -S -F'

alias fd='find . -type d -iname'
alias ff='find . -type f -iname'

alias vim='nvim'
alias bashrc='exec ${SHELL} -l'
alias hgrep='history | grep'
alias mkdir='mkdir -p'
alias open='xdg-open'
alias tmux-create='tmux new-session -A -s'
alias asciinema-record='asciinema rec -i 1.5 --overwrite'

alias .1='cd ..'
alias .2='cd ../..'
alias .3='cd ../../..'
alias .4='cd ../../../..'
alias .5='cd ../../../../..'

alias yarnpkg='corepack yarnpkg'
alias yarn='corepack yarn'
alias pnpm='corepack pnpm'
alias pnpx='corepack pnpm dlx'
alias npm='corepack npm'
alias npx='corepack npx'

alias k='kubectl'
alias kctx="k kc switch"
alias kns="k kc namespace"
alias knet='kubectl run -it --rm "$USER-knet" \
    --image=praqma/network-multitool \
    --restart=Never -- /bin/bash'

alias path='echo -e ${PATH//:/\\n}'

command_exists() {
    local CMD

    for CMD in "$@"; do
        command -v "$CMD" &>/dev/null
    done
}

container_cmd() {
    local CONTAINER_ENGINE

    [[ -n "${CONTAINER_ENGINE_PREFERENCE:-}" ]] && {
        command_exists "$CONTAINER_ENGINE_PREFERENCE" &&
            echo "$CONTAINER_ENGINE_PREFERENCE" && return 0
    }
    for CONTAINER_ENGINE in docker podman; do
        command_exists "$CONTAINER_ENGINE" && echo $CONTAINER_ENGINE && return 0
    done

    echo >&2 "${FUNCNAME[1]} error: requires docker or podman"
    return 1
}

dik() {
    [[ $# -ne 2 ]] && {
        echo >&2 "Usage: ${FUNCNAME[0]} RECORD_TYPE DOMAIN"
        return 1
    }
    dig +nocmd "$1" "$2" +multiline +noall +answer
}

diff() {
    [[ $# -ne 2 ]] && {
        echo >&2 "Usage: ${FUNCNAME[0]} FILE1 FILE2"
        return 1
    }
    git diff --no-index --color-words "$@"
}

mkd() {
    [[ $# -lt 1 ]] && {
        echo >&2 "Usage: ${FUNCNAME[0]} DIR..."
        return 1
    }
    mkdir -p "$@" && cd "$_" || return 1
}

tmpd() {
    cd "$(mktemp -d ${1:+-t "$1".XXXXXXXXXX})" || return 1
}

fs() {
    [[ -n "$*" ]] && du -sbh -- "$@" || du -sbh .[^.]* ./*
}

cat() {
    command_exists 'bat' && bat "$@" || command cat "$@"
}

asciinema_to_gif() {
    local CONTAINER_CMD

    CONTAINER_CMD=$(container_cmd) || return 1

    [[ $# -ne 2 ]] && {
        echo >&2 "Usage: ${FUNCNAME[0]} INPUT.cast OUTPUT.gif"
        return 1
    }

    [[ ! -f "$1" ]] && {
        echo >&2 "Error: '$1' not found"
        return 1
    }

    $CONTAINER_CMD run --rm -u "$(id -u):$(id -g)" -v "$PWD:/data" \
        ghcr.io/asciinema/agg "$1" "$2"
}

choose_status_bar() {
    local PS3="Choose a status bar:" CHOICE REPLY

    local -r I3_CONFIG_DIR="$XDG_CONFIG_HOME/i3"
    local -r I3_CURRENT_STATUS_BAR_SYMLINK="$I3_CONFIG_DIR/i3-bar"

    local -ra OPTIONS=(
        "Polybar"
        "Bumblebee"
        "Quit"
    )

    command_exists 'bumblebee-status' 'polybar' || {
        echo 2>&1 "There are no status bar to choose from"
        return 1
    }

    show_options() {
        for i in "${!OPTIONS[@]}"; do
            printf "${GREEN}%d)${NC} %s\n" $((i + 1)) "${OPTIONS[$i]}"
        done
    }
    select CHOICE in "${OPTIONS[@]}"; do
        case $CHOICE in
        Polybar)
            ln -sfn "$I3_CONFIG_DIR/i3bar/polybar" "$I3_CURRENT_STATUS_BAR_SYMLINK"
            i3-msg restart &>/dev/null
            echo -e "${GREEN}$CHOICE activated${NC}"
            break
            ;;
        Bumblebee)
            polybar-msg cmd quit &>/dev/null
            ln -sfn "$I3_CONFIG_DIR/i3bar/bumblebee-status" "$I3_CURRENT_STATUS_BAR_SYMLINK"
            i3-msg restart &>/dev/null
            echo -e "${GREEN}$CHOICE activated${NC}"
            break
            ;;
        Quit)
            break
            ;;
        *)
            echo -e "${RED}ï± Invalid option: ${REPLY}${NC}"
            show_options
            ;;
        esac
    done
    unset -f show_options
}

eza() {
    command_exists 'eza' || {
        echo 2>&1 "${FUNCNAME[0]} not found in your PATH"
        return 1
    }
    command eza -lnioa --git --smart-group \
        --no-permissions --time-style=long-iso "$@"
}

yy() {
    local TMP CWD

    TMP="$(mktemp -t "yazi-cwd.XXXXXX")"
    yazi "$@" --cwd-file="$TMP"
    IFS= read -r -d '' CWD <"$TMP"
    [ -n "$CWD" ] && [ "$CWD" != "$PWD" ] && cd -- "$CWD" || return 1
    rm -f -- "$TMP"
}

search() {
    [[ $# -ne 1 ]] && {
        echo >&2 "Usage: ${FUNCNAME[0]} SEARCH_TERM"
        return 1
    }
    open "https://www.google.com/search?q=$1"
}

ckp() {
    [[ $# -ne 1 ]] && {
        echo >&2 "Usage: ${FUNCNAME[0]} PORT"
        return 1
    }
    sudo lsof -ni4TCP:"$1" || echo "Port $1 is not bound"
}

kp() {
    [[ $# -ne 1 ]] && {
        echo >&2 "Usage: ${FUNCNAME[0]} PORT"
        return 1
    }
    sudo fuser -k -n tcp "$1" || echo "Port $1 is not bound"
}

copycat() {
    [[ $# -ne 1 ]] && {
        echo >&2 "Usage: ${FUNCNAME[0]} FILE"
        return 1
    }
    command cat "$1" | xclip -selection clipboard
}

datauri() {
    [[ $# -ne 1 ]] && {
        echo >&2 "Usage: ${FUNCNAME[0]} FILE"
        return 1
    }
    local MIMETYPE
    MIMETYPE=$(file -b --mime-type "$1")

    if [[ $MIMETYPE == text/* ]]; then
        MIMETYPE="${MIMETYPE};charset=utf-8"
    fi

    echo "data:${MIMETYPE};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

unidecode() {
    perl -e "binmode(STDOUT, ':utf8'); print \"$*\""
    [[ -t 1 ]] && echo ""
}

codepoint() {
    perl -e "use utf8; print sprintf('U+%04X', ord(\"$*\"))"
    [[ -t 1 ]] && echo ""
}

isup() {
    [[ $# -ne 1 ]] && {
        echo >&2 "Usage: ${FUNCNAME[0]} DOMAIN"
        return 1
    }
    curl -sSLfI -m 5 -XGET -A "Mozilla/5.0 (X11; BSD; Linux x86_64; rv:1)" "$1" >/dev/null &&
        notify-send -u low -t 2000 "$1 is UP" ||
        notify-send -u critical -t 2000 "$1 is DOWN"
}

epoch() {
    local TIMESTAMP=${1:--1}
    printf '%(%B %d, %Y %-I:%M:%S %p %Z)T\n' "$TIMESTAMP"
}

shortener() {
    [[ $# -ne 1 ]] && {
        echo >&2 "Usage: ${FUNCNAME[0]} URL"
        return 1
    }
    curl -s -XPOST https://api.tinyurl.com/create \
        -H "Authorization: Bearer $TINYURL_TOKEN" \
        -H 'Content-type: application/json' \
        -d "{ \"url\": \"$1\" }" | jq -r '.data.tiny_url'
}

readcert() {
    [[ $# -ne 1 ]] && {
        echo >&2 "Usage: ${FUNCNAME[0]} DOMAIN"
        return 1
    }
    local -ra CERT_OPTS=(
        "no_aux"
        "no_header"
        "no_pubkey"
        "no_serial"
        "no_sigdump"
        "no_signame"
        "no_validity"
        "no_version"
    )

    local -r CERT_INFO=$(echo | openssl s_client -connect "$1:443" -servername "$1" 2>/dev/null |
        openssl x509 -text -certopt "$(printf "%s," "${CERT_OPTS[@]}" | sed 's/,$//')" 2>/dev/null) || {
        echo >&2 "Error: Failed to fetch certificate for $1"
        return 1
    }

    echo -e "${YELLOW}Certificate for $1:${NC}"
    echo "$CERT_INFO"

    return 0
}
